# -*- coding: utf-8 -*-
"""A*_Algorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Av43GPE48nc6ufb_qMyy_MuIkszRxc0d

This code implements the A* search algorithm to find the shortest path between two cities in a weighted graph, using a heuristic function to guide the search.

First, we define the graph representing the cities and the distances between them. Each key in the `graph` dictionary is a city, and its value is another dictionary where keys are neighboring cities and values are the distances to those neighbors.
"""

import heapq
from dataclasses import dataclass

graph = {
    "Lahore": {"Islamabad": 270, "Faisalabad": 180},
    "Islamabad": {"Lahore": 270, "Peshawar": 190},
    "Faisalabad": {"Lahore": 180, "Multan": 220},
    "Multan": {"Faisalabad": 220, "Karachi": 880},
    "Peshawar": {"Islamabad": 190},
    "Karachi": {"Multan": 880}
}

"""Next, we define a heuristic function which estimates the distance from each city to the goal city ("Karachi"). The heuristic must be admissible, meaning it never overestimates the actual distance to the goal."""

heuristic = {
    "Lahore": 1210,
    "Islamabad": 1100,
    "Faisalabad": 1050,
    "Multan": 880,
    "Peshawar": 1250,
    "Karachi": 0
}

"""We use a dataclass `Node` to store information about each node in the search. `f_cost` is the estimated total cost from the start to the goal through this node (g_cost + h_cost), `name` is the city name, and `path` is the list of cities visited to reach this node. The `order=True` argument allows us to use this dataclass directly in a priority queue."""

@dataclass(order=True)
class Node:
    f_cost: float
    name: str
    path: list

"""The `a_star` function implements the A* search algorithm. It uses a priority queue (`open_list`) to store nodes to be explored, prioritized by their f-cost. `g_costs` stores the best-known cost to reach each node from the start, and `closed_set` stores nodes that have been fully explored."""

def a_star(graph, start, goal, heuristic):
    open_list = []
    heapq.heappush(open_list, Node(heuristic[start], start, [start]))
    g_costs = {start: 0}
    closed_set = set()

    while open_list:
        current_node = heapq.heappop(open_list)
        node_name = current_node.name
        path = current_node.path

        if node_name == goal:
            return path, g_costs[node_name]

        if node_name in closed_set:
            continue

        closed_set.add(node_name)

        for neighbor_name, cost in graph[node_name].items():
            tentative_g = g_costs[node_name] + cost

            if neighbor_name not in g_costs or tentative_g < g_costs[neighbor_name]:
                g_costs[neighbor_name] = tentative_g
                f_cost = tentative_g + heuristic.get(neighbor_name, float('inf'))
                new_path = path + [neighbor_name]
                heapq.heappush(open_list, Node(f_cost, neighbor_name, new_path))

    return None, float('inf')

"""Finally, we demonstrate how to use the `a_star` function with "Lahore" as the start city and "Karachi" as the goal city, and print the resulting path and total cost."""

if __name__ == "__main__":
    start_city = "Peshawar"
    goal_city = "Multan"
    path, cost = a_star(graph, start_city, goal_city, heuristic)
    print("A* path:", path)
    print("Total cost:", cost)